# CLAUDE.md — Claude Code 開発ガイドライン

> 本文書の【MUST】【SHOULD】【MAY】は、RFC 2119に準拠します：
> - 【MUST GLOBAL】：MUSTの上位概念。プロジェクトごとのCLAUDE.mdより優先される
> - 【MUST】: 絶対的要求事項。例外なく従う必要がある
> - 【SHOULD】: 強い推奨事項。特別な理由がない限り従う
> - 【MAY】: 任意事項。状況に応じて採用を判断

## 【MUST GLOBAL】基本理念

### 応答原則
- 回答は**すべて日本語**、簡潔・明瞭を徹底
- 不明確な点は「不明」と素直に伝える
- agentが使用できる場合は常にagentを使用する

### 曖昧な要求への対応

- **推測禁止**: 不明な点は必ず質問する
- **確認優先**: 「○○という理解で正しいですか？」と確認
- **最小実行**: 明示的に要求されたことのみ実行

### 禁止行為チェックリスト
- [ ] 要求されていない機能の追加
- [ ] 勝手なリファクタリング  
- [ ] 推測に基づく実装
- [ ] 「ついでに」の作業
- [ ] 親切心からの拡大解釈

### 実行前の自問自答

1. これは明示的に要求されたか？ → NO なら実行しない
2. 解釈に推測が含まれているか？ → YES なら質問する
3. 「ついでに」やろうとしていないか？ → YES なら止める

### 品質哲学
- **読み手に優しいコード** — 次のエンジニアがすぐ理解できる
- **品質最優先** — 妥協を許さず最高水準を追求
- **シンプルさこそ正義（KISS）** — 最も単純で意図が明快な実装
- **ボーイスカウト・ルール** — 触れたモジュールは「来たときよりきれい」に
- **不要な外部依存を追加しない** — 必要最小限の依存関係を維持

### 【悪い例】vs【良い例】

❌ ユーザー: 「ログイン機能を作って」
Claude: セキュリティも重要だから2要素認証も実装しました！

✅ ユーザー: 「ログイン機能を作って」
 Claude: ログイン機能について確認させてください：

- メール/パスワード認証でよろしいですか？
- セッション管理の要件はありますか？
- 既存の認証gemの使用は可能ですか？```

---

## プロジェクトルートCLAUDE.mdの構成
各プロジェクトルートのCLAUDE.mdは以下構成とする。

1. プロジェクトの概要
2. システム構成図
3. 機能一覧
4. 画面一覧
5. 技術スタック
6. 使用するコマンド
7. ディレクトリ構成
8. メインコード実装方針
9. 単体テストコード実装方針
10. 結合・統合テスト実装方針
11. その他プロジェクトに関する必要事項
12. 注意事項
13. 参照ドキュメント

---

## ディレクトリ構成
各プロジェクトルートのディレクトリ構成は以下とする。

```
project-root/
  |- .claude/: Claude用ディレクトリ
  |- .devcontainer/: vscodeのdevcontainer専用ディレクトリ
  |   |- docker-compose.yml: devcontainerで使用するdocker-composeファイルはここに配置
  |- .external/: 外部接続（必要な場合）のモックプログラム
  |   |- docs/: モック仕様書のドキュメント
  |   |   |- common.md: 共通で使用するエンドポイント
  |   |- main.py
  |   |- venv/: pythonを動かすvenv環境
  |   |- requirements.txt
  |   ∟ README.md
  |- docs/: ドキュメント関連
  |   |- requirements.md:  要件定義書
  |   |- design.md: 設計書
  |   |- database.md: DB仕様書
  |   |- screen.md: 画面仕様書
  |   |- external/: 外部接続IF仕様書
  |   |   |- systemA.yaml: システムAの外部接続IF仕様書
  |   |   |- systemB.yaml: システムBの外部接続IF仕様書 
  |   |- ifspec.yaml: backend用IF仕様書
  |   |- note/: その他ドキュメントファイルを格納
  |- backend: バックエンドアプリケーション
  |   |- src
  |   |- test
  |- frontend: フロントエンドアプリケーション
  |   |- src
  |   |- test
  |- poc: 試作
  |   |- backend
  |   |- frontend
  |- .tmp/: 一時ディレクトリ
  |- .context/: コンテキストエンジニアリング用ディレクトリ
      |- context_202511162154.md
```

---

## Gitブランチ戦略

### ブランチ
- **main**: メインブランチ
- **stg（staging）**: 検証用ブランチ
- **dev（develop）**: 開発用ブランチ

### 修正時のブランチ戦略

コードを修正するには以下ブランチ戦略をとってください。
- **新規ブランチ戦略**: 開発用ブランチを分岐させる
- **命名規則**:
  - **新規機能リリース**: `release/XXX`
  - **バグ修正**: `fix/XXX`
  - **削除**: `delete/XXX`
  - **リファクタ**: `refactor/XXX`

### コミットメッセージ書き方
- **タイトル**: [RELEASE/FIX/DELETE/REFACTOR]: <修正内容>
  - 簡潔で明確に、何を変更したかを一行で表現
  - 日本語で記述

#### 具体例

##### 1. 新規機能リリース（RELEASE）
```
[RELEASE]: ユーザー認証機能の追加

- JWT認証を実装
- ログイン・ログアウトエンドポイントを追加
- セッション管理機能を実装
- 認証ミドルウェアを追加
```

##### 2. バグ修正（FIX）
```
[FIX]: 削除フラグが更新されない不具合の修正

- 削除処理時にis_deletedフラグが更新されていなかった問題を修正
- deleted_atタイムスタンプも併せて記録するよう変更
- UserRepository.delete()メソッドを修正
- 関連する単体テストを追加
```

#### コミットメッセージの構成要素

1. **タイトル（必須）**: `[種別]: 変更内容の要約`
2. **本文（推奨）**:
   - なぜその変更が必要だったか（WHY）
   - 何を変更したか（WHAT）
   - 関連するファイルやモジュール
   - 影響範囲や注意点

---

## コンテキスト駆動開発について

### コンテキスト駆動開発とは

**コンテキスト駆動開発（Context-Driven Development）** は、AIアシスタント（Claude Code等）に対して、プロジェクトの背景・要件・設計・制約などの「コンテキスト情報」を構造化して提供することで、より正確で一貫性のある開発を実現する手法です。

#### 目的
- AIアシスタントに対する情報提供の一貫性を保つ
- プロジェクトの背景や意図を明確に伝える
- 開発の文脈を保持し、品質の高い実装を実現
- チーム間での知識共有とドキュメント化

### コンテキストの書き方

コンテキストファイルは、AIアシスタントが理解しやすいように構造化されたMarkdown形式で記述します。

#### 基本構成

```markdown
# コンテキスト: [機能名・タスク名]

## 1. 背景・目的
なぜこの機能が必要か、どんな課題を解決するか

## 2. 要件
- 必須要件
- オプション要件
- 制約事項

## 3. 設計方針
- アーキテクチャ
- 技術選定の理由
- パフォーマンス要件

## 4. 実装の詳細
- ディレクトリ構成
- 主要なクラス/関数
- データフロー

## 5. テスト方針
- 単体テストの方針
- 統合テストの方針
- カバレッジ目標

## 6. 注意事項・制約
- セキュリティ上の考慮事項
- パフォーマンス上の制約
- 外部依存関係

## 7. 参照ドキュメント
- 関連する設計書
- API仕様書
- 外部ライブラリのドキュメント
```

#### 良いコンテキストの特徴

✅ **具体的**: 曖昧さを排除し、明確に記述
✅ **構造化**: セクションごとに整理され読みやすい
✅ **必要十分**: 過不足なく情報を提供
✅ **更新可能**: プロジェクト進行に応じて更新

❌ **避けるべき記述**
- 曖昧な表現（「できれば」「なるべく」など）
- 推測に基づく記述
- 古い情報のまま放置

#### 記述例

```markdown
# コンテキスト: ユーザー認証機能

## 1. 背景・目的
現状、ユーザー認証機能が存在せず、誰でもAPIにアクセスできる状態。
セキュリティ強化のため、JWT認証を導入する。

## 2. 要件
- JWTトークンによる認証（必須）
- アクセストークン有効期限: 1時間
- リフレッシュトークン有効期限: 7日間
- ログイン・ログアウト機能
- トークンのブラックリスト管理（ログアウト時）

## 3. 設計方針
- ライブラリ: jsonwebtoken (npm)
- 秘密鍵管理: 環境変数から取得
- ミドルウェアパターンで認証チェック実装
- データベース: PostgreSQL（ユーザー情報、ブラックリスト）

## 4. 実装の詳細
### ディレクトリ構成
\```
backend/src/
  |- auth/
  |   |- middleware/authMiddleware.ts  # 認証ミドルウェア
  |   |- controllers/authController.ts # ログイン・ログアウト処理
  |   |- services/tokenService.ts      # トークン生成・検証
  |   |- repositories/tokenRepository.ts # ブラックリスト管理
\```

### 主要なクラス/関数
- `AuthController.login()`: ログイン処理
- `AuthController.logout()`: ログアウト処理
- `TokenService.generateToken()`: トークン生成
- `TokenService.verifyToken()`: トークン検証
- `authMiddleware()`: 認証チェックミドルウェア

## 5. テスト方針
- 単体テスト: 各サービス・コントローラーの機能テスト
- 統合テスト: ログインからAPI呼び出しまでの一連の流れ
- カバレッジ目標: 80%以上

## 6. ユーザへの確認事項
実装前にユーザーに確認すべき事項を記載します。推測や曖昧な要件を排除し、明確な合意を得るための質問をリストアップします。

### 確認すべき項目の例
- **認証方式**: OAuth2.0、JWT、セッションベースのいずれを採用するか？
- **トークン有効期限**: アクセストークンとリフレッシュトークンの有効期限は？
- **エラーハンドリング**: 認証失敗時のレスポンス仕様（ステータスコード、エラーメッセージ形式）
- **既存システムとの連携**: 既存の認証システムがある場合、統合方法は？
- **ユーザー情報の取得**: ログイン時にどの情報を取得・保持するか（ユーザーID、メールアドレス、権限など）
- **パスワードポリシー**: 最低文字数、複雑性要件、有効期限など
- **多要素認証（MFA）**: 導入する必要があるか？
- **ログアウト処理**: トークンの無効化方法（ブラックリスト、データベース削除など）

### 記述例
- アクセストークンの有効期限は1時間でよろしいですか？それとも別の期間が必要ですか？
- リフレッシュトークンは7日間の有効期限で問題ありませんか？
- 認証失敗時は401エラーを返す仕様でよろしいですか？エラーメッセージの詳細度はどの程度必要ですか？
- 既存のユーザーテーブルを使用しますか？それとも新規に作成しますか？
- パスワードのハッシュ化にはbcryptを使用する予定ですが、別のアルゴリズムの指定はありますか？

## 7. 注意事項・制約
- 秘密鍵は絶対にコミットしない（.envで管理）
- トークンの有効期限切れ時は401エラーを返す
- CORS設定を適切に行う

## 8. 参照ドキュメント
- [JWT公式ドキュメント](https://jwt.io/)
- `docs/design.md`: 全体設計書
- `docs/ifspec.yaml`: API仕様書
```

### コンテキストファイル保存先

`.context/YYYYMMDDhhmmss.md`に保存

#### 命名規則
- フォーマット: `YYYYMMDDhhmmss.md`
- 例: `20251127143000.md`（2025年11月27日 14:30:00）

#### 使用方法
1. 新しいタスクや機能開発の開始時にコンテキストファイルを作成
2. AIアシスタントに対して「`.context/20251127143000.md`の内容に基づいて実装してください」と指示
3. プロジェクト進行に応じて内容を更新
4. 完了後もドキュメントとして保持

#### メリット
- タイムスタンプにより時系列での追跡が可能
- 過去の意思決定や設計の経緯を保存
- チームメンバー間での情報共有が容易
- AIアシスタントへの指示が簡潔になる

---

## 外部接続モックプログラム

### 概要
Python+FastAPIを利用した外部接続をモックするプログラム。

### 起動方法
```bash
cd .external && ./venv/bin/python3 -m uvicorn src.main:app --host 0.0.0.0 --port 9100 --reload
```
